Found 59 Java files to compile
Compiling: .\src\main\java\magma\compile\Actual.java
Successfully compiled: .\src\main\java\magma\compile\Actual.java
Compiling: .\src\main\java\magma\compile\collect\Accumulator.java
Successfully compiled: .\src\main\java\magma\compile\collect\Accumulator.java
Compiling: .\src\main\java\magma\compile\context\Context.java
Successfully compiled: .\src\main\java\magma\compile\context\Context.java
Compiling: .\src\main\java\magma\compile\context\NodeContext.java
Successfully compiled: .\src\main\java\magma\compile\context\NodeContext.java
Compiling: .\src\main\java\magma\compile\context\StringContext.java
Successfully compiled: .\src\main\java\magma\compile\context\StringContext.java
Compiling: .\src\main\java\magma\compile\error\ApplicationError.java
Successfully compiled: .\src\main\java\magma\compile\error\ApplicationError.java
Compiling: .\src\main\java\magma\compile\error\CompileError.java
Successfully compiled: .\src\main\java\magma\compile\error\CompileError.java
Compiling: .\src\main\java\magma\compile\error\Error.java
Successfully compiled: .\src\main\java\magma\compile\error\Error.java
Compiling: .\src\main\java\magma\compile\error\ThrowableError.java
Successfully compiled: .\src\main\java\magma\compile\error\ThrowableError.java
Compiling: .\src\main\java\magma\compile\JavaSerializer.java
Successfully compiled: .\src\main\java\magma\compile\JavaSerializer.java
Compiling: .\src\main\java\magma\compile\Lang.java
Successfully compiled: .\src\main\java\magma\compile\Lang.java
Compiling: .\src\main\java\magma\compile\Node.java
Successfully compiled: .\src\main\java\magma\compile\Node.java
Compiling: .\src\main\java\magma\compile\rule\BraceStartFolder.java
Successfully compiled: .\src\main\java\magma\compile\rule\BraceStartFolder.java
Compiling: .\src\main\java\magma\compile\rule\ClosingParenthesesFolder.java
Successfully compiled: .\src\main\java\magma\compile\rule\ClosingParenthesesFolder.java
Compiling: .\src\main\java\magma\compile\rule\DelimitedRule.java
Successfully compiled: .\src\main\java\magma\compile\rule\DelimitedRule.java
Compiling: .\src\main\java\magma\compile\rule\Divider.java
Successfully compiled: .\src\main\java\magma\compile\rule\Divider.java
Compiling: .\src\main\java\magma\compile\rule\DivideState.java
Failed to compile .\src\main\java\magma\compile\rule\DivideState.java: 0) Failed to lex segments for key 'children': package magma.compile.rule;

import magma.Tuple;
import magma.option.None;
import magma.option.Option;
import magma.option.Some;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}

	0) Failed to lex segment: 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
		0) No alternative matched for input: 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
			0) Failed to attach tag 'package': 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
				0) Prefix 'package ' not present: public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
			1) Failed to attach tag 'import': 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
				0) Prefix 'import ' not present: public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
			2) Failed to attach tag 'block-comment': 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
				0) Prefix '/*' not present: public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
			3) Failed to attach tag 'whitespace': 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
				0) Content is not empty: public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
			4) No alternative matched for input: 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
				0) Failed to attach tag 'interface': 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
					0) Infix 'interface ' not present: public class DivideState 
				1) Failed to attach tag 'record': 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
					0) Infix 'record ' not present: public class DivideState 
				2) Failed to attach tag 'class': 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
					0) Failed to lex segments for key 'children': 
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}

						0) Failed to lex segment: 
	public final List<String> segments;
							0) No alternative matched for input: 
	public final List<String> segments;
								0) Infix '=' not present: public final List<String> segments
								1) Failed to attach tag 'line-comment': 
	public final List<String> segments;
									0) Prefix '//' not present: public final List<String> segments;
								2) Failed to attach tag 'block-comment': 
	public final List<String> segments;
									0) Prefix '/*' not present: public final List<String> segments;
								3) Failed to attach tag 'whitespace': 
	public final List<String> segments;
									0) Content is not empty: public final List<String> segments;
								4) No alternative matched for input: 
	public final List<String> segments;
									0) Failed to attach tag 'class': 
	public final List<String> segments;
										0) Suffix '}' not present: public final List<String> segments;
									1) Failed to attach tag 'interface': 
	public final List<String> segments;
										0) Suffix '}' not present: public final List<String> segments;
									2) Failed to attach tag 'record': 
	public final List<String> segments;
										0) Suffix '}' not present: public final List<String> segments;
								5) Failed to attach tag 'method': 
	public final List<String> segments;
									0) No alternative matched for input: public final List<String> segments;
										0) Suffix ')' not present: public final List<String> segments
										1) Suffix '}' not present: public final List<String> segments;
0) Failed to lex segments for key 'children': package magma.compile.rule;

import magma.Tuple;
import magma.option.None;
import magma.option.Option;
import magma.option.Some;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}

	0) Failed to lex segment: 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
		0) No alternative matched for input: 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
			0) Failed to attach tag 'package': 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
				0) Prefix 'package ' not present: public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
			1) Failed to attach tag 'import': 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
				0) Prefix 'import ' not present: public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
			2) Failed to attach tag 'block-comment': 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
				0) Prefix '/*' not present: public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
			3) Failed to attach tag 'whitespace': 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
				0) Content is not empty: public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
			4) No alternative matched for input: 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
				0) Failed to attach tag 'interface': 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
					0) Infix 'interface ' not present: public class DivideState 
				1) Failed to attach tag 'record': 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
					0) Infix 'record ' not present: public class DivideState 
				2) Failed to attach tag 'class': 

public class DivideState {
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}
}
					0) Failed to lex segments for key 'children': 
	public final List<String> segments;
	private final String input;
	private StringBuilder buffer;
	private int depth;
	private int index;

	public DivideState(StringBuilder buffer, int depth, List<String> segments, String input) {
		this.buffer = buffer; this.depth = depth; this.segments = segments; this.input = input;
	}

	public DivideState(String input) {
		this(new StringBuilder(), 0, new ArrayList<>(), input);
	}

	Stream<String> stream() {
		return segments.stream();
	}

	public DivideState enter() {
		this.depth = depth + 1; return this;
	}

	public DivideState advance() {
		segments.add(buffer.toString()); this.buffer = new StringBuilder(); return this;
	}

	public DivideState append(char c) {
		buffer.append(c); return this;
	}

	public DivideState exit() {
		this.depth = depth - 1; return this;
	}

	public boolean isShallow() {
		return depth == 1;
	}

	public boolean isLevel() {
		return depth == 0;
	}

	public Option<Character> pop() {
		if (index >= input.length()) return Option.empty(); final char c = input.charAt(index); index++;
		return Option.of(c);
	}

	public Option<Tuple<DivideState, Character>> popAndAppendToTuple() {
		return pop().map(popped -> new Tuple<>(append(popped), popped));
	}

	public Option<DivideState> popAndAppendToOption() {
		return popAndAppendToTuple().map(Tuple::left);
	}

	public Option<Character> peek() {
		if (index < input.length()) return new Some<>(input.charAt(index));
		else return new None<>();
	}

						0) Failed to lex segment: 
	public final List<String> segments;
							0) No alternative matched for input: 
	public final List<String> segments;
								0) Infix '=' not present: public final List<String> segments
								1) Failed to attach tag 'line-comment': 
	public final List<String> segments;
									0) Prefix '//' not present: public final List<String> segments;
								2) Failed to attach tag 'block-comment': 
	public final List<String> segments;
									0) Prefix '/*' not present: public final List<String> segments;
								3) Failed to attach tag 'whitespace': 
	public final List<String> segments;
									0) Content is not empty: public final List<String> segments;
								4) No alternative matched for input: 
	public final List<String> segments;
									0) Failed to attach tag 'class': 
	public final List<String> segments;
										0) Suffix '}' not present: public final List<String> segments;
									1) Failed to attach tag 'interface': 
	public final List<String> segments;
										0) Suffix '}' not present: public final List<String> segments;
									2) Failed to attach tag 'record': 
	public final List<String> segments;
										0) Suffix '}' not present: public final List<String> segments;
								5) Failed to attach tag 'method': 
	public final List<String> segments;
									0) No alternative matched for input: public final List<String> segments;
										0) Suffix ')' not present: public final List<String> segments
										1) Suffix '}' not present: public final List<String> segments;

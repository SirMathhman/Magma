Found 59 Java files to compile
Compiling: .\src\main\java\magma\compile\Actual.java
Successfully compiled: .\src\main\java\magma\compile\Actual.java
Compiling: .\src\main\java\magma\compile\collect\Accumulator.java
Successfully compiled: .\src\main\java\magma\compile\collect\Accumulator.java
Compiling: .\src\main\java\magma\compile\context\Context.java
Successfully compiled: .\src\main\java\magma\compile\context\Context.java
Compiling: .\src\main\java\magma\compile\context\NodeContext.java
Successfully compiled: .\src\main\java\magma\compile\context\NodeContext.java
Compiling: .\src\main\java\magma\compile\context\StringContext.java
Successfully compiled: .\src\main\java\magma\compile\context\StringContext.java
Compiling: .\src\main\java\magma\compile\error\ApplicationError.java
Successfully compiled: .\src\main\java\magma\compile\error\ApplicationError.java
Compiling: .\src\main\java\magma\compile\error\CompileError.java
Successfully compiled: .\src\main\java\magma\compile\error\CompileError.java
Compiling: .\src\main\java\magma\compile\error\Error.java
Successfully compiled: .\src\main\java\magma\compile\error\Error.java
Compiling: .\src\main\java\magma\compile\error\ThrowableError.java
Successfully compiled: .\src\main\java\magma\compile\error\ThrowableError.java
Compiling: .\src\main\java\magma\compile\JavaSerializer.java
Successfully compiled: .\src\main\java\magma\compile\JavaSerializer.java
Compiling: .\src\main\java\magma\compile\Lang.java
Successfully compiled: .\src\main\java\magma\compile\Lang.java
Compiling: .\src\main\java\magma\compile\Node.java
Failed to compile .\src\main\java\magma\compile\Node.java: 0) Failed to lex segments for key 'children': package magma.compile;

import magma.option.None;
import magma.option.Option;
import magma.option.Some;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}

	0) Failed to lex segment: 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
		0) No alternative matched for input: 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
			0) Failed to attach tag 'package': 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
				0) Prefix 'package ' not present: public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
			1) Failed to attach tag 'import': 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
				0) Prefix 'import ' not present: public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
			2) Failed to attach tag 'block-comment': 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
				0) Prefix '/*' not present: public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
			3) Failed to attach tag 'whitespace': 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
				0) Content is not empty: public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
			4) No alternative matched for input: 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
				0) Failed to attach tag 'interface': 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
					0) Infix 'interface ' not present: public final class Node 
				1) Failed to attach tag 'record': 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
					0) Infix 'record ' not present: public final class Node 
				2) Failed to attach tag 'class': 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
					0) Failed to lex segments for key 'children': 
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}

						0) Failed to lex segment: 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
							0) No alternative matched for input: 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
								0) Suffix ';' not present: private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
								1) Failed to attach tag 'line-comment': 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
									0) Prefix '//' not present: private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
								2) Failed to attach tag 'block-comment': 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
									0) Prefix '/*' not present: private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
								3) Failed to attach tag 'whitespace': 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
									0) Content is not empty: private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
								4) No alternative matched for input: 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
									0) Failed to attach tag 'class': 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
										0) Infix 'class ' not present: private String appendJsonPure(int indentDepth, int level, int maxLevel) 
									1) Failed to attach tag 'interface': 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
										0) Infix 'interface ' not present: private String appendJsonPure(int indentDepth, int level, int maxLevel) 
									2) Failed to attach tag 'record': 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
										0) Infix 'record ' not present: private String appendJsonPure(int indentDepth, int level, int maxLevel) 
								5) Failed to attach tag 'method': 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
									0) No alternative matched for input: private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
										0) Suffix ';' not present: private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
										1) Failed to lex segments for key 'body': 
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	
											0) Failed to lex segment: 

		boolean[] hasFields = {false};
												0) No alternative matched for input: boolean[] hasFields = {false};
													0) Failed to attach tag 'whitespace': boolean[] hasFields = {false};
														0) Content is not empty: boolean[] hasFields = {false};
													1) Failed to attach tag 'line-comment': boolean[] hasFields = {false};
														0) Prefix '//' not present: boolean[] hasFields = {false};
													2) Failed to attach tag 'if': boolean[] hasFields = {false};
														0) Prefix 'if ' not present: boolean[] hasFields = {false};
													3) Failed to attach tag 'while': boolean[] hasFields = {false};
														0) Prefix 'while ' not present: boolean[] hasFields = {false};
													4) Failed to attach tag 'switch': boolean[] hasFields = {false};
														0) Prefix 'switch ' not present: boolean[] hasFields = {false};
													5) Failed to attach tag 'else': boolean[] hasFields = {false};
														0) Prefix 'else' not present: boolean[] hasFields = {false};
													6) Failed to attach tag 'try': boolean[] hasFields = {false};
														0) Prefix 'try ' not present: boolean[] hasFields = {false};
													7) Failed to attach tag 'catch': boolean[] hasFields = {false};
														0) Prefix 'catch ' not present: boolean[] hasFields = {false};
													8) Failed to attach tag 'block': boolean[] hasFields = {false};
														0) Prefix '{' not present: boolean[] hasFields = {false};
													9) No alternative matched for input: boolean[] hasFields = {false}
														0) Failed to attach tag 'break': boolean[] hasFields = {false}
															0) Prefix 'break' not present: boolean[] hasFields = {false}
														1) Failed to attach tag 'return': boolean[] hasFields = {false}
															0) Prefix 'return ' not present: boolean[] hasFields = {false}
														2) Failed to attach tag 'postFix': boolean[] hasFields = {false}
															0) Suffix '++' not present: boolean[] hasFields = {false}
														3) No alternative matched for input: boolean[] hasFields = {false}
															0) Failed to attach tag 'invocation': boolean[] hasFields = {false}
																0) No segments found.: boolean[] hasFields = {false}
															1) Failed to attach tag 'construction': boolean[] hasFields = {false}
																0) No segments found.: boolean[] hasFields = {false}
														4) No alternative matched for input:  {false}
															0) Failed to attach tag 'lambda':  {false}
																0) Infix '->' not present:  {false}
															1) Failed to attach tag 'char':  {false}
																0) Prefix ''' not present: {false}
															2) Failed to attach tag 'cast':  {false}
																0) Prefix '(' not present: {false}
															3) Failed to attach tag 'quantity':  {false}
																0) Prefix '(' not present: {false}
															4) Failed to attach tag 'not':  {false}
																0) Prefix '!' not present: {false}
															5) Failed to attach tag 'string':  {false}
																0) Prefix '"' not present: {false}
															6) Failed to attach tag 'switch':  {false}
																0) Prefix 'switch ' not present: {false}
															7) Failed to attach tag 'index':  {false}
																0) Suffix ']' not present: {false}
															8) Failed to attach tag 'new-array':  {false}
																0) Suffix ']' not present: {false}
															9) Failed to attach tag 'index':  {false}
																0) Suffix ']' not present: {false}
															10) Failed to attach tag 'field-access':  {false}
																0) Infix '.' not present:  {false}
															11) Failed to attach tag 'instanceof':  {false}
																0) Infix 'instanceof' not present:  {false}
															12) Failed to attach tag 'add':  {false}
																0) Infix '+' not present:  {false}
															13) Failed to attach tag 'subtract':  {false}
																0) Infix '-' not present:  {false}
															14) Failed to attach tag 'and':  {false}
																0) Infix '&&' not present:  {false}
															15) Failed to attach tag 'equals':  {false}
																0) Infix '==' not present:  {false}
															16) Failed to attach tag 'less-than':  {false}
																0) Infix '<' not present:  {false}
															17) Failed to attach tag 'less-than-equals':  {false}
																0) Infix '<=' not present:  {false}
															18) Failed to attach tag 'identifier':  {false}
																0) Not an identifier: {false}
															19) No alternative matched for input:  {false}
																0) Failed to attach tag 'invocation':  {false}
																	0) No segments found.:  {false}
																1) Failed to attach tag 'construction':  {false}
																	0) No segments found.:  {false}
														5) Failed to attach tag 'definition': boolean[] hasFields = {false}
															0) No alternative matched for input: boolean[] hasFields =
																0) No alternative matched for input: =
																	0) Failed to attach tag 'generic': =
																		0) Suffix '>' not present: =
																	1) Failed to attach tag 'array': =
																		0) Suffix '[]' not present: =
																	2) Failed to attach tag 'identifier': =
																		0) Not an identifier: =
																	3) Failed to attach tag 'wildcard': =
																		0) Prefix '?' not present: =
																1) No alternative matched for input: boolean[] hasFields =
																	0) Failed to attach tag 'generic': boolean[] hasFields =
																		0) Suffix '>' not present: boolean[] hasFields =
																	1) Failed to attach tag 'array': boolean[] hasFields =
																		0) Suffix '[]' not present: boolean[] hasFields =
																	2) Failed to attach tag 'identifier': boolean[] hasFields =
																		0) Not an identifier: boolean[] hasFields =
																	3) Failed to attach tag 'wildcard': boolean[] hasFields =
																		0) Prefix '?' not present: boolean[] hasFields =
0) Failed to lex segments for key 'children': package magma.compile;

import magma.option.None;
import magma.option.Option;
import magma.option.Some;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}

	0) Failed to lex segment: 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
		0) No alternative matched for input: 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
			0) Failed to attach tag 'package': 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
				0) Prefix 'package ' not present: public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
			1) Failed to attach tag 'import': 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
				0) Prefix 'import ' not present: public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
			2) Failed to attach tag 'block-comment': 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
				0) Prefix '/*' not present: public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
			3) Failed to attach tag 'whitespace': 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
				0) Content is not empty: public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
			4) No alternative matched for input: 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
				0) Failed to attach tag 'interface': 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
					0) Infix 'interface ' not present: public final class Node 
				1) Failed to attach tag 'record': 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
					0) Infix 'record ' not present: public final class Node 
				2) Failed to attach tag 'class': 

public final class Node {
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
}
					0) Failed to lex segments for key 'children': 
	private static final int MAX_FORMAT_LEVEL = 2;
	public final Map<String, List<Node>> nodeLists = new HashMap<>();
	public final Map<String, Node> nodes = new HashMap<>();
	private final Map<String, String> strings = new HashMap<>();
	public Option<String> maybeType = Option.empty();

	private static String escape(String value) {
		return value.replace("\\", "\\\\")
								.replace("\"", "\\\"")
								.replace("\n", "\\n")
								.replace("\r", "\\r")
								.replace("\t", "\\t");
	}

	@Override
	public String toString() {
		return format(0);
	}

	public Node withString(String key, String value) {
		strings.put(key, value);
		return this;
	}

	public Option<String> findString(String key) {
		return Option.ofNullable(strings.get(key));
	}

	public Node merge(Node node) {
		maybeType = switch (maybeType) {
			case None<String> _ -> node.maybeType;
			case Some<String> _ -> maybeType;
		};
		this.strings.putAll(node.strings);
		nodeLists.putAll(node.nodeLists);
		nodes.putAll(node.nodes);
		return this;
	}

	public Node withNodeList(String key, List<Node> values) {
		nodeLists.put(key, values);
		return this;
	}

	public Option<List<Node>> findNodeList(String key) {
		return Option.ofNullable(nodeLists.get(key));
	}

	public Node withNode(String key, Node node) {
		nodes.put(key, node);
		return this;
	}

	public Option<Node> findNode(String key) {
		return Option.ofNullable(nodes.get(key));
	}

	public Node retype(String type) {
		this.maybeType = Option.of(type);
		return this;
	}

	public boolean is(String type) {
		return this.maybeType.map(inner -> inner.equals(type)).orElse(false);
	}

	public Set<String> getStringKeys() {
		return strings.keySet();
	}

	public String format(int depth) {
		return format(depth, MAX_FORMAT_LEVEL);
	}

	public String format(int depth, int maxLevel) {
		String indent = "\t".repeat(depth);
		return indent + appendJsonPure(depth, 0, maxLevel);
	}

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}

						0) Failed to lex segment: 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
							0) No alternative matched for input: 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
								0) Suffix ';' not present: private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
								1) Failed to attach tag 'line-comment': 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
									0) Prefix '//' not present: private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
								2) Failed to attach tag 'block-comment': 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
									0) Prefix '/*' not present: private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
								3) Failed to attach tag 'whitespace': 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
									0) Content is not empty: private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
								4) No alternative matched for input: 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
									0) Failed to attach tag 'class': 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
										0) Infix 'class ' not present: private String appendJsonPure(int indentDepth, int level, int maxLevel) 
									1) Failed to attach tag 'interface': 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
										0) Infix 'interface ' not present: private String appendJsonPure(int indentDepth, int level, int maxLevel) 
									2) Failed to attach tag 'record': 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
										0) Infix 'record ' not present: private String appendJsonPure(int indentDepth, int level, int maxLevel) 
								5) Failed to attach tag 'method': 

	private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
									0) No alternative matched for input: private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
										0) Suffix ';' not present: private String appendJsonPure(int indentDepth, int level, int maxLevel) {
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	}
										1) Failed to lex segments for key 'body': 
		final String indent = "\t".repeat(indentDepth);
		final String childIndent = "\t".repeat(indentDepth + 1);
		StringBuilder builder = new StringBuilder();
		builder.append("{");

		boolean[] hasFields = {false};

		Option<String> typeOpt = maybeType;
		if (typeOpt instanceof Some<String>(String value)) {
			builder.append("\n").append(childIndent).append("\"@type\": \"").append(escape(value)).append("\"");
			hasFields[0] = true;
		}

		strings.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent)
						 .append('"')
						 .append(escape(entry.getKey()))
						 .append("\": \"")
						 .append(escape(entry.getValue()))
						 .append('"');
			hasFields[0] = true;
		});

		nodes.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": ");
			if (level + 1 < maxLevel) builder.append(entry.getValue().appendJsonPure(indentDepth + 1, level + 1, maxLevel));
			else builder.append("{...}");
			hasFields[0] = true;
		});

		nodeLists.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
			if (hasFields[0]) builder.append(",\n");
			else builder.append("\n");
			builder.append(childIndent).append('"').append(escape(entry.getKey())).append("\": [");
			List<Node> list = entry.getValue();
			if (!list.isEmpty()) if (level + 1 < maxLevel) {
				builder.append("\n");
				builder.append(list.stream()
													 .map(node -> "\t".repeat(indentDepth + 2) +
																				node.appendJsonPure(indentDepth + 2, level + 1, maxLevel))
													 .collect(Collectors.joining(",\n")));
				builder.append("\n").append(childIndent);
			} else builder.append("...");
			builder.append("]");
			hasFields[0] = true;
		});

		if (hasFields[0]) builder.append("\n").append(indent);
		builder.append("}");
		return builder.toString();
	
											0) Failed to lex segment: 

		boolean[] hasFields = {false};
												0) No alternative matched for input: boolean[] hasFields = {false};
													0) Failed to attach tag 'whitespace': boolean[] hasFields = {false};
														0) Content is not empty: boolean[] hasFields = {false};
													1) Failed to attach tag 'line-comment': boolean[] hasFields = {false};
														0) Prefix '//' not present: boolean[] hasFields = {false};
													2) Failed to attach tag 'if': boolean[] hasFields = {false};
														0) Prefix 'if ' not present: boolean[] hasFields = {false};
													3) Failed to attach tag 'while': boolean[] hasFields = {false};
														0) Prefix 'while ' not present: boolean[] hasFields = {false};
													4) Failed to attach tag 'switch': boolean[] hasFields = {false};
														0) Prefix 'switch ' not present: boolean[] hasFields = {false};
													5) Failed to attach tag 'else': boolean[] hasFields = {false};
														0) Prefix 'else' not present: boolean[] hasFields = {false};
													6) Failed to attach tag 'try': boolean[] hasFields = {false};
														0) Prefix 'try ' not present: boolean[] hasFields = {false};
													7) Failed to attach tag 'catch': boolean[] hasFields = {false};
														0) Prefix 'catch ' not present: boolean[] hasFields = {false};
													8) Failed to attach tag 'block': boolean[] hasFields = {false};
														0) Prefix '{' not present: boolean[] hasFields = {false};
													9) No alternative matched for input: boolean[] hasFields = {false}
														0) Failed to attach tag 'break': boolean[] hasFields = {false}
															0) Prefix 'break' not present: boolean[] hasFields = {false}
														1) Failed to attach tag 'return': boolean[] hasFields = {false}
															0) Prefix 'return ' not present: boolean[] hasFields = {false}
														2) Failed to attach tag 'postFix': boolean[] hasFields = {false}
															0) Suffix '++' not present: boolean[] hasFields = {false}
														3) No alternative matched for input: boolean[] hasFields = {false}
															0) Failed to attach tag 'invocation': boolean[] hasFields = {false}
																0) No segments found.: boolean[] hasFields = {false}
															1) Failed to attach tag 'construction': boolean[] hasFields = {false}
																0) No segments found.: boolean[] hasFields = {false}
														4) No alternative matched for input:  {false}
															0) Failed to attach tag 'lambda':  {false}
																0) Infix '->' not present:  {false}
															1) Failed to attach tag 'char':  {false}
																0) Prefix ''' not present: {false}
															2) Failed to attach tag 'cast':  {false}
																0) Prefix '(' not present: {false}
															3) Failed to attach tag 'quantity':  {false}
																0) Prefix '(' not present: {false}
															4) Failed to attach tag 'not':  {false}
																0) Prefix '!' not present: {false}
															5) Failed to attach tag 'string':  {false}
																0) Prefix '"' not present: {false}
															6) Failed to attach tag 'switch':  {false}
																0) Prefix 'switch ' not present: {false}
															7) Failed to attach tag 'index':  {false}
																0) Suffix ']' not present: {false}
															8) Failed to attach tag 'new-array':  {false}
																0) Suffix ']' not present: {false}
															9) Failed to attach tag 'index':  {false}
																0) Suffix ']' not present: {false}
															10) Failed to attach tag 'field-access':  {false}
																0) Infix '.' not present:  {false}
															11) Failed to attach tag 'instanceof':  {false}
																0) Infix 'instanceof' not present:  {false}
															12) Failed to attach tag 'add':  {false}
																0) Infix '+' not present:  {false}
															13) Failed to attach tag 'subtract':  {false}
																0) Infix '-' not present:  {false}
															14) Failed to attach tag 'and':  {false}
																0) Infix '&&' not present:  {false}
															15) Failed to attach tag 'equals':  {false}
																0) Infix '==' not present:  {false}
															16) Failed to attach tag 'less-than':  {false}
																0) Infix '<' not present:  {false}
															17) Failed to attach tag 'less-than-equals':  {false}
																0) Infix '<=' not present:  {false}
															18) Failed to attach tag 'identifier':  {false}
																0) Not an identifier: {false}
															19) No alternative matched for input:  {false}
																0) Failed to attach tag 'invocation':  {false}
																	0) No segments found.:  {false}
																1) Failed to attach tag 'construction':  {false}
																	0) No segments found.:  {false}
														5) Failed to attach tag 'definition': boolean[] hasFields = {false}
															0) No alternative matched for input: boolean[] hasFields =
																0) No alternative matched for input: =
																	0) Failed to attach tag 'generic': =
																		0) Suffix '>' not present: =
																	1) Failed to attach tag 'array': =
																		0) Suffix '[]' not present: =
																	2) Failed to attach tag 'identifier': =
																		0) Not an identifier: =
																	3) Failed to attach tag 'wildcard': =
																		0) Prefix '?' not present: =
																1) No alternative matched for input: boolean[] hasFields =
																	0) Failed to attach tag 'generic': boolean[] hasFields =
																		0) Suffix '>' not present: boolean[] hasFields =
																	1) Failed to attach tag 'array': boolean[] hasFields =
																		0) Suffix '[]' not present: boolean[] hasFields =
																	2) Failed to attach tag 'identifier': boolean[] hasFields =
																		0) Not an identifier: boolean[] hasFields =
																	3) Failed to attach tag 'wildcard': boolean[] hasFields =
																		0) Prefix '?' not present: boolean[] hasFields =

### While Loops and Returns
Control flow now includes `while` loops alongside existing `if` statements. The
loop parser mirrors the conditional logic so arbitrary statements can appear
within the loop body, including nested blocks. Functions with non-`Void` return
types are compiled through the same block parser, allowing `return` statements
to appear anywhere rather than being fixed to a single `return 0;` form. This
keeps the implementation uniform while still validating basic type correctness.

### Break and Continue
`break` and `continue` provide early exits and iteration skipping for loops.
The parser recognizes these statements with small regular expressions so the
overall block parser stays uncomplicated. Tests ensure they behave as expected
without extra context tracking, and the compiler simply copies them into the
generated C code.

### Condition Handling Cleanup
As more control flow features appeared, the comparisons used in `if` and `while`
statements duplicated logic for validating operand types and translating boolean
literals to `1` or `0`. A small helper now converts these conditions into C
syntax. This keeps the block parser shallow and avoids repeating nested
expressions.

### Type Conversion Helpers
As the compiler grew, repeated checks converted Magma types to C types and
translated booleans to `1` or `0`. The new `c_type_of` and `bool_to_c`
helpers centralize these conversions so all parts of the compiler share the
same implementation. This reduces duplication and makes further changes
easier to reason about.

### Return Statement Helper
As constructors generated by `class fn` and regular function bodies both needed
to emit `return` statements, code duplication crept in. The `emit_return`
helper now produces these statements with or without a value so that every
return site follows the same formatting logic. This keeps the output uniform
and the compiler simpler to maintain.

### Expression Processing Helper
Repeated parsing logic appeared when handling arithmetic and function call
expressions across variable declarations, assignments, and returns. A single
`analyze_expr` helper now validates expressions using Python's `ast` module,
determines their resulting type, and rewrites field references to include the
`this.` prefix when omitted. This ensures expressions like `test(1 + 2 + 3)` or
`return value;` are handled consistently without duplicating parsing code.

### Parameter Parsing Helper
Parameter handling for nested functions, class methods, and top-level
declarations used to repeat the same checks and conversions. The new
`parse_params` helper centralizes this work by translating a comma-separated
list of parameters into constructor fields and C argument declarations while
rejecting invalid bounds. This shortens the compiler loop and keeps all
parameter validation in one place.


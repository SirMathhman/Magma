/*
Pointers in Magma have a length AND a capacity. In pratice, this is just a C struct
that has the pointer, length, and capacity as fields.

The syntax is `*[Type; Length; Capacity]`, where
- `Type` is the type of data being stored.
- `Length` is the total number of elements present.
- `Capacity` is the total capacity of the array.

For example, you can `malloc(sizeof<I32> * 3)`, and get `*[I32; 0; 3]`.
This allows us to check at compile time whether memory is uninitialized.

Furthermore, this forces us to initialize `array[0]` and `array[1]` before `array[2]`.
*/

/*
The syntax <= indicates a subset type. That is, `Allocated` is a subset of:

- *[Type; Length; Capacity]
- Drop({drop : free})
*/
type Allocated<Type, Length, Capacity> <= *[Type; Length; Capacity] & Drop({drop : free});

import stdlib;
extern fn free<Type, Length, Capacity>(ptr : Allocated<Type, Length, Capacity>) : Void;
extern fn malloc<Type, Length, Capacity>(size : sizeOf<Type> * Length) : Allocated<Type, Length, Capacity>;

class fn ArrayList<T>() => {
  let array : *[T; 0; 0] = malloc(0);

  fn expandTo(index : USize) => {
    let oldCapacity = array.capacity;
    if (index < oldCapacity) return;

    let mut newCapacity = oldCapacity == 0 ? 1 : oldCapacity;
    while (index >= newCapacity) newCapacity *= 2;
    let result = realloc(array, sizeOf<T> * newCapacity);
    if (result != 0) array = result;
  }

  fn set(index : USize, element : T) => {
    expandTo(index);

    if(index >= array.length) {
      for(let mut i = 0; i < index; i++) {
        array[i] = default<T>;
      }
    }
    array[index] = element;
  }

  fn get(index : USize) => array[index];
  fn add(element : T) => set(size, element);
  fn drop() => {
    if (T is Drop) {
      for (let mut i = 0; i < size; i++) {
        array[i].drop();
      }
    }
    free(array)
  }

  with Drop;
}

let mut list = ArrayList();
list.add(2);
list.add(3);
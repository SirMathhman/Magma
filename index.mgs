/*
Pointers in Magma have a length AND a capacity. In pratice, this is just a C struct
that has the pointer, length, and capacity as fields.

The syntax is `*[Type; Length; Capacity]`, where
- `Type` is the type of data being stored.
- `Length` is the total number of elements present.
- `Capacity` is the total capacity of the array.

For example, you can `malloc(sizeof<I32> * 3)`, and get `*[I32; 0; 3]`.
This allows us to check at compile time whether memory is uninitialized.

Furthermore, this forces us to initialize `array[0]` and `array[1]` before `array[2]`.
*/

/*
The syntax <= indicates a subset type. That is, `Allocated` is a subset of:

- *[Type; Length; Capacity]
- Drop({drop : free})
*/
type Allocated<Type, Length, Capacity> <= *[Type; Length; Capacity] & Drop({drop : free});

import stdlib;
extern fn free<Type, Length, Capacity>(ptr : Allocated<Type, Length, Capacity>) : Void;
extern fn malloc<Type, Length, Capacity>(size : sizeOf<Type> * Length) : Allocated<Type, Length, Capacity> | 0;
extern fn realloc<Type, OldLength, OldCapacity, NewLength, NewCapacity>(ptr : Allocated<Type, OldLength, OldCapacity>, size : sizeOf<Type> * NewLength) : Allocated<Type, NewLength, NewCapacity> | 0;

module Collections {
  require(onAllocationFailure : USize => Void);

  class fn ArrayList<T>() => {
    let array : *[T; 0; 0] = malloc(0);

    fn expandTo(index : USize) => {
      let oldCapacity = array.capacity;
      if (index < oldCapacity) return;

      let mut newCapacity : USize = oldCapacity == 0 ? 1 : oldCapacity;
      while (index >= newCapacity) {
        newCapacity *= 2
      
            // Check overflow for sizeOf<T> * newCapacity
            // maxOf is built-in.
            if (newCapacity > maxOf<USize> / sizeOf<T>) {
              // Report that requested capacity would overflow and abort expansion.
              onAllocationFailure(newCapacity);
              return;
            }
      }
      
      let result = realloc(array, sizeOf<T> * newCapacity);
      if (result == 0) {
        onAllocationFailure(newCapacity);
        return;
      }
      array = result;
    }

    fn set(index : USize, element : T) => {
      expandTo(index);

      // This sets array[index] as element, and backfills from `array[length]` to `array[index - 1]` with the default value.
      array.padAndSet(index, element, () => default<T>);
      // Ensure the pointer length reflects the newly-initialized element.
      if (index >= array.length) {
        array.length = index + 1;
      }
    }

    // USize < array.length is a refined type.
    fn get(index : USize < array.length) => array[index];
    fn add(element : T) => set(array.length, element);
    fn drop() => {
      if (T is Drop) {
        for (let mut i = 0; i < array.length; i++) {
          array[i].drop();
        }
      }
      free(array)
    }

    with Drop;
  }
}

fn onAllocationFailure(size : USize) => {
 panic("allocation failed: requested capacity too large");
}

let mut list = Collections(onAllocationFailure)::ArrayList();
list.add(2);
list.add(3);
// Simple HashMap implementation for Magma standard library
// Generic over key and value types. Uses separate chaining with lists.

type Entry<K, V> = { key: K, val: V, next: *Entry<K,V> };

fn hashStr(s : String) : I32 => {
    var h = 2166136261;
    var i = 0;
    while (i < s.length()) {
        h = (h ^ s.charCodeAt(i)) * 16777619;
        i = i + 1;
    }
    // keep in signed 32-bit range
    return (h & 0x7fffffff) as I32;
}

fn defaultHash<K>(k : K) : I32 => {
    // Provide a few common cases; fallback to 0
    if (typeof(k) == "string") return hashStr(k as String);
    if (typeof(k) == "number") return (k as I32);
    return 0;
}

type HashMap<K, V> = {
    buckets: *[]*Entry<K,V>,
    capacity: I32,
    size: I32
};

fn newHashMap<K, V>(cap : I32) : HashMap<K,V> => {
    var b = [];
    var i = 0;
    while (i < cap) { b = b + [null]; i = i + 1; }
    return { buckets: b, capacity: cap, size: 0 };
}

fn bucketIndex<K>(m : HashMap<K,V>, key : K) : I32 => {
    var h = defaultHash(key);
    return h % m.capacity;
}

fn get<K, V>(m : HashMap<K,V>, key : K) : V => {
    var idx = bucketIndex(m, key);
    var e = m.buckets[idx];
    while (e != null) {
        if (e.key == key) return e.val;
        e = e.next;
    }
    // absent: return default V (assumed to be 0/false/null)
    return null;
}

fn set<K, V>(m : HashMap<K,V>, key : K, value : V) : () => {
    var idx = bucketIndex(m, key);
    var e = m.buckets[idx];
    while (e != null) {
        if (e.key == key) { e.val = value; return; }
        e = e.next;
    }
    // insert at head
    var ne = { key: key, val: value, next: m.buckets[idx] };
    m.buckets[idx] = ne;
    m.size = m.size + 1;
};

fn contains<K, V>(m : HashMap<K,V>, key : K) : Bool => {
    var idx = bucketIndex(m, key);
    var e = m.buckets[idx];
    while (e != null) { if (e.key == key) return true; e = e.next; }
    return false;
}

fn remove<K, V>(m : HashMap<K,V>, key : K) : Bool => {
    var idx = bucketIndex(m, key);
    var e = m.buckets[idx];
    var prev = null;
    while (e != null) {
        if (e.key == key) {
            if (prev == null) m.buckets[idx] = e.next;
            else prev.next = e.next;
            m.size = m.size - 1;
            return true;
        }
        prev = e;
        e = e.next;
    }
    return false;
}

fn len<K, V>(m : HashMap<K,V>) : I32 => m.size;

class fn Some<T>(value : T) => {
}

type Option<T> = Some<T> | None<T>;

class fn Ok<T, X>(value : T) => {

}

class fn Err<T, X>(error : X) => {

}

type Result<T, X> = Ok<T, X> | Err<T, X>;

class fn String(slice : &[U8]) => {
}

class fn Interpreter() => {
	fn tryFinalLiteralInDeclarations(finalPart : String) : Option<Result<String, InterpretError>> => {
		let finalTrim = finalPart.trim();
		let leadDigits = if (finalTrim.isEmpty()) 0 else leadingDigits(finalTrim);
		if (leadDigits > 0) return Some(Ok(finalTrim.substring(0, leadDigits)));
		return None;
	}
}

5

struct Ok<T, X> {
}

struct Err<T, X> {
}

type Result<T, X> = Ok<T, X> | Err<T, X>;

struct String {
}

impl String {
  fn trim() : String => {
    // TODO
  }

  fn length() : USize => {
    // TODO
  }

  fn isEmpty() => length() == 0;
}

module I32 {
  fn tryParse(value : I32) : Option<String> => {
    // TODO
    return None(); 
  }
}

fn isInteger(s : String) => {
  if (s.isEmpty())
    return false;

  return I32.tryParse(s).isPresent();
}

fn interpret(input : String) : Result<String, InterpretError> => {
  let mut trimmed = input.trim();

  while (trimmed.length() >= 2 && trimmed.get(0) == '{' && trimmed.get(trimmed.length() - 1) == '}') {
    trimmed = trimmed.slice(1, trimmed.length() - 1).trim();
  }
}